1. Advantages of Hibernate:
	- Object-Oriented(ORM) Framework is itself an advantage
	- Supports lazy loading for improved performance
	- Caching
	- Auto DDL creation

========================================================================================================================================================

2. Types of Relationship:

	1) one to one:
		- Table: Person ( personid, name, passportid ) , Passport ( passportid, locstion, personid )
		- Entity: Person ( personid, name, passport ) , Passport ( passportid, locstion, person )
	
	2) One to many / Many to one:
		- Table: Author ( authorId, name ) , Book ( bookId, title, authorId )
		- Entity: PAuthor ( authorId, name, list<books> ) , Book ( bookId, title, author )
	
	3) many to many:
		- Table: Students  ( studentsId, name ) , Courses  ( coursesId, name ) , Student_Course ( studentsId, coursesId )
		- Entity: Students  ( studentsId, name, list<courses> ) , Courses  ( coursesId, name, list<students> ) , Student_Course ( studentsId, coursesId )

@JoinColumn - for one to one and one to many
@JoinTable - for many to many


========================================================================================================================================================

3. First-Level Cache(default):
		- Session-Level Cache.
		- When the session is closed or cleared, the first-level cache is destroyed.
		- It is not designed for concurrent processes and it is not thread safe.
		
   Second-Level Cache
		- Session Factory-Level Cache.
		- It is designed for concurrent processes and it is thread safe.
		- to enable add this to properties file: spring.jpa.hibernate.cache.use_second_level_cache=true
		

========================================================================================================================================================

4. Important hibernate properties:
	
	- hibernate.show_sql: true/false -> Enables or disables the display of SQL statements in the console.
	- hibernate.hbm2ddl.auto: create/update/validate -> Defines how Hibernate should handle schema generation.
	- hibernate.c3p0.min_size & hibernate.c3p0.max_size -> Minimum and Maximum number of database connections in the connection pool

========================================================================================================================================================

5. hibernate.hbm2ddl.auto: create/update/validate:

	- none(default) -- Hibernate will not create or update or validate the database schema based on your entity mappings.
	- create -- If the database already exists, it will be dropped and recreated.
	- update -- It will add new tables and columns for newly mapped entities and fields, but it won't drop or modify existing tables. 
	- validate -- it checks whether the mappings are consistent with the database structure. If there are inconsistencies, you'll receive errors or warnings.

========================================================================================================================================================

6. Fetch Type:

	- fetch = FetchType.EAGER -> It is Default for @ManyToOne and @OneToOne.
	- fetch = FetchType.LAZY -> It is Default for @OneToMany.
		Author author = session.get(Author.class, authorId); // Load the author.
		List<Book> books = author.getBooks(); // Load the books associated with the author only when it is accessed.
	
========================================================================================================================================================

7. N+1 problem in hibernate:

	- Suppose you have a list of authors and their books:
		-> You fetch a list of authors (N authors) from the database.
		-> When you access the books for each author, Hibernate generates a separate SQL query to load the books for each author (1 query per author).
		-> In this scenario, you end up with N authors and N SQL queries to fetch their books, resulting in a total of N+1 queries.

	- Solutions:
		-> Eager Loading
		-> Fetch using join query

========================================================================================================================================================

8. What is the use of Cascade during entity relationship?

	- Defines how associated entities should behave when we perform certain operation on the entity.
	- There is no default option, if we won't specify, cascading won't happen.

	- CascadeType.PERSIST: When an entity is saved, associated entities will also be saved. This is useful for maintaining the integrity of related objects.
	- CascadeType.MERGE: When an entity is merged into the persistence context (e.g., via EntityManager.merge()), associated entities will also be merged.
	- CascadeType.REMOVE: When an entity is removed, associated entities will also be removed. This is useful for ensuring that related data is deleted when the owning entity is deleted.
	- CascadeType.REFRESH: When an entity is refreshed (e.g., via EntityManager.refresh()), associated entities are also refreshed, which can be useful for synchronizing the state of the object graph with the database.
	- CascadeType.DETACH: When an entity is detached from the persistence context (e.g., via EntityManager.detach()), associated entities are also detached. This can be used when you want to remove an entity from the context without affecting its associated entities.
	- CascadeType.ALL: This cascade option includes all the above operations (PERSIST, MERGE, REMOVE, REFRESH, DETACH). It's a shorthand way to specify that all cascade operations should be applied.

========================================================================================================================================================
9. Steps to implement basic Stored Procedure using Spring Data JPA:


	
=======================================================================================================================================================

10. How to create composite primary key in jpa entity class & JPA Repository?

		@Entity
		public class YourEntity {
			@EmbeddedId
			private YourCompositeKey compositeKey;
		}

		@Embeddable
		public class YourCompositeKey implements Serializable {
			private Long firstKey;
			private String secondKey;
		}
		
		//Repository
		public interface YourEntityRepository extends JpaRepository<YourEntity, YourCompositeKey> {
		}
		
=======================================================================================================================================================

11. primary keys:
	- Is it possible to create a table without a primary key? yes, but not a good practice.

=======================================================================================================================================================

13. Steps to configure multiple datasource:




=======================================================================================================================================================

13. Handle Pagination using Spring-data JPA




=======================================================================================================================================================